<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>ghwlchlaks.github.io/</title>
   
   <link>https://ghwlchlaks.github.io</link>
   <description>같이 배워가는 IT 블로그입니다~. Python, JavaScript, nodejs, Github, algorithm, etc</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>면접 공부04 (정리전)</title>
	  <link>//interview04</link>
	  <author></author>
	  <pubDate>2019-04-11T09:00:00+09:00</pubDate>
	  <guid>//interview04</guid>
	  <description><![CDATA[
	     <h2 id="면접-공부">면접 공부</h2>

<p>세션,쿠키,로컬스토리지 차이</p>
<ul>
  <li>
    <p>쿠키 : 서버측과 클라이언트측 양쪽에서 쿠키데이터를 사용하는 api가 존재하고, 소멸시간을 지정할 수 있으며, 4kb내의 데이터만 보관할 수 있습니다. 또한 매 http 통신시 쿠키 정보가 함께 전송되기 때문에 로컬/세션스토리지를 사용할때보다 미세하게나마 통신속도가 느림,</p>
  </li>
  <li>
    <p>로컬 스토리지 : 오직 클라이언트쪽에서만 작동이됩니다. 소멸시간이 없으며 사용자가 직접 지우거나 특정 조건이 만족된다면 소멸합니다. 로컬스토리지와 세션스토리지의 차이는 소멸 시점에 있습니다. 영구적인것과 영구적이지 않는 것의 차이입니다. 로컬스토리지는 사용자가 지우지 않는 이상 영구적으로 남아있지만 세션스토리지는 웹 브라우저를 닫는 순간 사라지게됩니다.</p>
  </li>
  <li>
    <p>세션 - 쿠키는 클라이언트에 세션은 서버에 저장, 쿠키는 클라이언트 로컬에 저장되기 때문에 보안에 취약하지만 세션은 서버에 저장하기 때문에 비교적 보안성이 좋다.</p>
  </li>
</ul>

<p>세션을 주로 사용하면 좋은데 왜 쿠키를 사용할까?</p>
<ul>
  <li>세션은 서버의 자원을 사용하기 때문에 무분별하게 만들다보면 서버의 메모리가 감당할 수 없어질 수가 있고 속도가 느려질 수 있기 때문이다.</li>
</ul>

<p>쿠키, 세션은 캐시와 다르다</p>
<ul>
  <li>캐시는 이미지나, css, js 파일등이 사용자의 브라우저에 저장되는 것, 이를 이용해 자원이 아껴지는 것</li>
</ul>

<p>성취감이 높았던 업무 경험 물어봄</p>
<ul>
  <li>가장 성취감이 높았던 경험은 공모전이었습니다. 이유는 처음으로 팀을 구성하여 참여했던 프로젝트이고 학부에서 배우는 과정을 제외하고 기술들에대해서 새롭게 공부하여 프로젝트를 구축한 경험 이를 통해 수상까지 했던 경험이라 팀원들과 저 모두 뿌듯하고 성취감이 높았던 경험이었습니다.</li>
</ul>

<p>리액트와 뷰의 차이
1) 데이터 변경 방법</p>
<ul>
  <li>name이 choi인 객체가 있다고 가정했을 때 해당 값을 변경하기 위해서 vue는 this.name=로 접근하여 변경하면 되지만, react에서는 this.setState()로 변경을 해야합니다. vue에서는 data를 업데이트할때마다 setState를 알아서 결합해줍니다.
그러면 react에서는 왜 setState를 필요로할까?</li>
  <li>react에서는 라이플사이클 중인 componentwillreceiveProps, shouldcomponentuUpdate등 이 존재하는데 state를 변경할때마다 다시 실행됩니다. 이 라이프사이클 메소드를 통해 변경된 state를 알기위해 사용합니다. 
공통점</li>
  <li>가상돔 사용</li>
  <li>컴포넌트 중심 개발</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>면접 과제 전형 후기</title>
	  <link>//interview-review</link>
	  <author></author>
	  <pubDate>2019-04-10T09:00:00+09:00</pubDate>
	  <guid>//interview-review</guid>
	  <description><![CDATA[
	     <h2 id="면접-과제-전형-후기">면접 과제 전형 후기</h2>

<p>과제내용은 자세하게는 밝히지 못하지만 SPA를 이용하여 대학교 수강신청을 통한 시간표 생성 웹 서비스를 만드는 과제 였습니다.</p>

<p>개발기간은 약 4일 정도 주어졌고 개인적으로 열심히 했다고 생각하고 제출을 했습니다.</p>

<p>나름 주어진 조건 이외에 있으면 좋을것같은 기능을 추가했습니다.</p>

<p>결과는 빠르게 연락이 왔습니다. 최종 면접 일정이 잡혔습니다. 좋은 결과가 있기를 기대하며 최종 면접 대비를 해보겠습니다. ㅎㅎ</p>

<p>짧은 면접과제 후기 입니다.</p>

	  ]]></description>
	</item>

	<item>
	  <title>면접 공부04 (정리전)</title>
	  <link>//interview04</link>
	  <author></author>
	  <pubDate>2019-04-04T09:00:00+09:00</pubDate>
	  <guid>//interview04</guid>
	  <description><![CDATA[
	     <h2 id="면접-공부04">면접 공부04</h2>

<p>float을 없애는 방법</p>
<ul>
  <li>부모 요소에 overflow 속성 사용</li>
  <li>after 가상 선택자 사용 (클래스를 부여하지 않았지만 마치 역동적으로 클래스를 변경한 것과 같은 효과를 낼 수 있는 것)
-float으로 대응하는 방법</li>
</ul>

<p>display 종류</p>
<ul>
  <li>inline : 앞뒤로 줄바꿈 되지않음 (디폴트)</li>
  <li>block : 요소 앞뒤로 줄바꿈이됨</li>
  <li>none: 박스 생성 x, 공간차지 하지 않음</li>
  <li>inline-block : 박스 모양이 inline처럼 늘어섬</li>
</ul>

<p>position 종류</p>
<ul>
  <li>relative : static위치를 기준으로 주어진 픽셀만큼 이동 (상대적)</li>
  <li>absolute : position: static 속성을 가지고 있지 않은 부모 요소 기준으로 움짐임</li>
  <li>static : 디폴트 상태로 왼쪽에서 오른쪽, 위에서 아래로 쌓임</li>
  <li>fixed : 특정위치에 고정</li>
</ul>

<p>소프트웨어란?</p>
<ul>
  <li>컴퓨터 시스템을 효율적으로 운영하기위한 프로그램, 대표적으로 운영체제가 있다.</li>
</ul>

<p>웹프로그래밍이란?</p>
<ul>
  <li>사용자가 특정한 작업을 웹서버에 요청하게되면 서버가 이를 해결한 후 결과를 응답하는 구조이다.</li>
</ul>

<p>웹 처리 순서</p>
<ul>
  <li>1) 웹브라우저가 웹 서버에 어떠한 페이지를
요청</li>
  <li>2) 웹 서버는 웹 브라우저의 요청을 받아서 로직 처리</li>
  <li>3) 결과를 브라우저에게 전달</li>
</ul>

<p>oop란?</p>
<ul>
  <li>프로그래밍에 필요한 상태와 행위를 가진 객체를 만들고 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법</li>
</ul>

<p>apache nginx</p>
<ul>
  <li>apache는 접속당 cpu, memory 사용량이 상대적으로 많이 증가하여 무거운 소프트웨어</li>
  <li>apache keep alive방식은 일정시간 동안 접속을 끊지 않고 다음 접속을 기다린다. 정적인 파일들에대해 50%성능 향상을 보이지만 여러 사용자가 접속했을경우 성능저하가 급격하게 발생한다.</li>
  <li>mpm 방식은 apache가 받아들인 요청을 처리하기위해 child process로 분배하는 방식을 말한다.</li>
  <li>nginx event-driven 방식으로 cpu, memory사용량이 크게 증가하지 않는다.</li>
  <li>nginx 는 모듈을 설치 했을때 nginx자체를 재 컴파일 해야한다.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>style-components와 React [styled-components]</title>
	  <link>//styled-components</link>
	  <author></author>
	  <pubDate>2019-03-30T10:00:00+09:00</pubDate>
	  <guid>//styled-components</guid>
	  <description><![CDATA[
	     <p>이번에는 React에서 styled-components 라이브러리를 사용하여 실습을 해보겠습니다.</p>

<p>먼저 styled-components <a href="https://www.styled-components.com/docs/basics#installation">링크</a> 입니다.</p>

<h2 id="순서">순서</h2>
<blockquote>
  <ul>
    <li>라이브러리 설치</li>
    <li>예제 실습</li>
  </ul>
</blockquote>

<h3 id="1-라이브러리-설치">1. 라이브러리 설치</h3>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install --save styled-components
</code></pre></div></div>

<h3 id="2-예제-실습">2. 예제 실습</h3>
<h4 id="1">(1)</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React, { Component } from 'react';
import './App.css';
import styled from 'styled-components'

class App extends Component {
  render() {
    return (
      &lt;Wrapper&gt;
        &lt;Title&gt;
          Hello World
        &lt;/Title&gt;
      &lt;/Wrapper&gt;
    );
  }
}

const Title = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: palevioletred;
`;

const Wrapper = styled.section`
  padding: 4em;
  background: papayawhip;
`;

export default App;

</code></pre></div></div>

<h4 id="결과-화면-1">결과 화면 (1)</h4>
<p><img src="/assets/images/2019-03-30-styled-components/result1.png" /></p>

<p>css파일을 사용할 경우, css와 컴포넌트 파일이 떨어져있기 때문에 관리가 불편한 점이 있습니다. <br />
styled-components는 컴포넌트를 생성할때 스타일을 입히기 때문에 css파일을 따로 관리하지 않아도됩니다.</p>

<p>또한 props를 받아서 스타일에 적용시킬수도 있습니다.</p>
<h4 id="2">(2)</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React, { Component } from 'react';
import './App.css';
import styled from 'styled-components'

class App extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;Button&gt;Normal&lt;/Button&gt;
        &lt;Button primary&gt;Primary&lt;/Button&gt;
      &lt;/div&gt;
    );
  }
}

const Button = styled.button`
  background: ${props =&gt; props.primary ? "palevioletred" : "white"};
  color: ${props =&gt; props.primary ? "white" : "palevioletred"};

  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 3px;
`;


export default App;

</code></pre></div></div>

<h4 id="결과화면-2">결과화면 (2)</h4>
<p><img src="/assets/images/2019-03-30-styled-components/result2.png" /></p>

<p>위 코드처럼 컴포넌트에 primary props의 존재 유무에 따라 스타일을 동적으로 지정할 수 있습니다.</p>

<p>다음 예제를 진행해 보겠습니다.</p>

<h4 id="3">(3)</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import React, { Component } from 'react';
import './App.css';
import styled from 'styled-components'

class App extends Component {
  render() {
    return (
      &lt;div&gt;
        &lt;Button&gt;Normal Button&lt;/Button&gt;
        &lt;TomatoButton&gt;Tomato Button&lt;/TomatoButton&gt;
      &lt;/div&gt;
    );
  }
}

const Button = styled.button`
  color: palevioletred;
  font-size: 1em;
  margin: 1em;
  padding: 0.25em 1em;
  border: 2px solid palevioletred;
  border-radius: 3px;
`;

const TomatoButton = styled(Button)`
  color: tomato;
  border-color: tomato;
`;


export default App;

</code></pre></div></div>

<h4 id="결과화면-3">결과화면 (3)</h4>
<p><img src="/assets/images/2019-03-30-styled-components/result3.png" /></p>

<p>위에 코드는 style을 override한것입니다. 즉, 이전의 설정한 스타일을 포함하면서 새롭게 tomatobutton생성한 스타일로 덮어집니다.</p>

<p>이것으로 간단하게 styled-components 사용방법과 이점에대해서 알아봤습니다.</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~
같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>리눅스에서 지킬 설치 및 실행 [Jekyll]</title>
	  <link>//ubuntu-jekyll-installation</link>
	  <author></author>
	  <pubDate>2019-03-24T10:00:00+09:00</pubDate>
	  <guid>//ubuntu-jekyll-installation</guid>
	  <description><![CDATA[
	     <p>이번에는 리눅스 환경에서 jekyll를 설치하는 방법에대해서 알아보도록하겠습니다.</p>

<p>이번에 노트북을 리눅스 운영체제로 바꾸고 jekyll를 설치해본 경험을 바탕으로 작성하겠습니다.</p>

<p><strong>1. 루비 (Ruby) 설치!</strong><br />
먼저 ruby를 설치 해줍니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install ruby-dev
</code></pre></div></div>

<p><strong>2. 지킬 (Jekyll) 설치</strong><br />
jekyll를 설치 해보도록하겠습니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install jekyll
</code></pre></div></div>
<p>역시 리눅스는 간단한 명령어로 패키지를 설치할 수 있는 장점이 있네요 ㅎㅎ</p>

<p>하지만 jekyll 설치 애러가 나타나는 경우가 있습니다. 이때는 의존 소프트웨어를 설치해주어야합니다. 
참고한 <a href="https://github.com/sj26/mailcatcher/issues/144#issuecomment-48008579">링크</a>입니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install build-essential
</code></pre></div></div>
<p>해당 패키지가 설치되고 나서 다시 <code class="highlighter-rouge">apt-get install jekyll</code>명령어를 사용하시면 잘 작동하시는 것을 보실 수 있습니다.</p>

<p>이후 bundler를 설치 해줍니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install bundler 
bundle install
</code></pre></div></div>
<p>이때 nokogiri가 설치되지 않는 문제가 발생 할 수 있습니다. 
이때도 의존성 소프트웨어가 설치 되있지 않아서 생기는 문제입니다.
이 문제를 해결하기위해서는 해당 명령어를 이용하여 의존 패키지를 설치해줍니다.
참고한 <a href="https://nokogiri.org/tutorials/installing_nokogiri.html">링크</a>입니다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apt-get install patch ruby-dev zlib1g-dev liblzma-dev
</code></pre></div></div>
<p>설치가 된 이후 다시 <code class="highlighter-rouge">bundle install</code>명령어를 이용하여 설치를 진행해주시면 됩니다.</p>

<p>이후 과정이 오류없이 설치가 완료된다면 <code class="highlighter-rouge">bundle exec jekyll serve</code>명령어를 이용하여 github-page를 실행할 수 있습니다 
오류 없이 실행이 된다면 <code class="highlighter-rouge">http://localhost:4000/</code>으로 접속하시면 자신이 폴더내에서 수정한 블로그를 확인 할 수 있습니다.<br />
수정이 끝난 후에는 git push를 통해 업로드 하시면 적용가능합니다!</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~
같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[React-native] 설치 방법</title>
	  <link>//react-native-installation</link>
	  <author></author>
	  <pubDate>2019-03-24T09:00:00+09:00</pubDate>
	  <guid>//react-native-installation</guid>
	  <description><![CDATA[
	     <h1 id="해당-게시글은-작성-진행-중입니다"><code class="highlighter-rouge">해당 게시글은 작성 진행 중입니다.</code></h1>

<p>사전의 설치되있어야하는 프로그램
안드로이드 스튜디오, jdk
<a href="[https://facebook.github.io/react-native/docs/getting-started.html]">참고 링크</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install -g react-native-cli
</code></pre></div></div>

<h2 id="안드로이드-스튜디오에서-설치할-라이브러리">안드로이드 스튜디오에서 설치할 라이브러리</h2>
<p>Android SDK <br />
Android SDK Platform - Android SDK Platform 28  <br />
Performance (Intel ® HAXM) (See here for AMD)<br />
Android Virtual Device<br />
Intel x86 Atom_64 System Image or Google APIs Intel x86 Atom System Image</p>

<h2 id="안드로이드-sdk-환경변수-설정">안드로이드 sdk 환경변수 설정</h2>
<p><img src="/assets/images/2019-03-23-react-native-installation/sdk_path.png" /></p>

<h2 id="platform-tools-path-설정">platform tools path 설정</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c:\Users\YOUR_USERNAME\AppData\Local\Android\Sdk\platform-tools
</code></pre></div></div>

<h2 id="안드로이드-스튜디오-emulator-실행">안드로이드 스튜디오 emulator 실행</h2>

<h2 id="프로젝트-생성">프로젝트 생성</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>react-native init firstProject
</code></pre></div></div>

<h2 id="연결된-디바이스-검색">연결된 디바이스 검색</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>adb devices
</code></pre></div></div>
<p><img src="/assets/images/2019-03-23-react-native-installation/adb_list.png" /></p>

<h2 id="프로젝트-안드로이드-emulator로-실행">프로젝트 안드로이드 emulator로 실행</h2>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>react-native run-android
</code></pre></div></div>
<p><img src="/assets/images/2019-03-23-react-native-installation/result_android.png" /></p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[Nosql] 공부 (정리전)</title>
	  <link>//nosql-interview02</link>
	  <author></author>
	  <pubDate>2019-03-04T09:00:00+09:00</pubDate>
	  <guid>//nosql-interview02</guid>
	  <description><![CDATA[
	     <p>NoSql은 키-값이나 컬럼, 문서 형식 등의 데이터 모델을 이용, 비 관계형 데이터베이스
Nosql과 RDBMS와의 다른 점</p>

<ul>
  <li>스키마가 없다. (데이터 관계와 정해진 규격 (table-colmn의 정의))가 없다.</li>
  <li>관계 정의가 없으니 Join이 불가능 (reference(참조)와 같은 기능으로 비슷하게 구현 가능)</li>
  <li>분산처리(수평적 확장)를 쉽게 제공
왜 사용하는가?</li>
  <li>많은 양의 데이터를 효율적으로 처리가 필요할 때</li>
  <li>데이터의 분산처리, 빠른 쓰기가 필요할 떄</li>
  <li>분산처리를 하므로 특정서버에 장애가 발생했을때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조이기 때문에 사용</li>
</ul>

<p>대표적인 Nosql</p>

<ul>
  <li>키-밸류형: redis</li>
  <li>문서형: mongodb</li>
</ul>

<p>Mongodb</p>

<ul>
  <li>문서지향 데이터 베이스 : 내장 문서와 배열을 이용해서 복잡한 계층구조를 하나의 레코드로 표현 할 수 있다.(json, array)</li>
  <li>스키마가 없다. (필드 추가 및 제거가 자유로움)</li>
  <li>RDBMS보다 빠름.</li>
</ul>

<p>Memcached(Remote Dictionary Server)</p>

<ul>
  <li>키-밸류 저장소</li>
  <li>주 사용 사례 : 캐싱, 세션 관리, pub/sub, 순위표 (대형 포털에서는 static page, 검색결과 등을 캐쉬하는데 많이 사용)</li>
  <li>데이터가 메모리에만 저장되므로 빠름 (휘발성) -프로세스가 죽거나 장비가 종료되면 데이터가 사라짐</li>
  <li>만료가 되지 않더라고 더 이상 메모리에 넣을 용량이 없으면 LRU(Least recently used) 알고리즘에 의해 사라진다. (최근에 가장 적게 사용한 데이터 먼저)</li>
</ul>

<p>Redis와 Memcached의 차이점</p>

<ul>
  <li>Redis는 디스크와 메모리에 저장되는데도 속도가 빠르다.</li>
  <li>데이터가 메모리 디스크에 저장되기 때문에 불의의 경우에도 데이터 복구가 가능.</li>
  <li>저장소 메모리 재사용 없음. 명시적으로만 데이터 제거 가능</li>
  <li>Redis는 문자열 ,Set, Sorted set, Hash, List등 다양한 데이터 타입을 지원하지만 Memcached는 문자열만 지원</li>
</ul>

<p>Redis장점</p>

<ul>
  <li>리스트, 배열과 같은 데이터를 처리하는데 용이</li>
  <li>Mysql에 비해서 속도가 빠르다.</li>
  <li>여러 프로세스에서 동시에 같은 key에 대한 갱신을 요청할 경우, 원자성 처리로 데이터 부적합 방지(원자성 처리 함수 제공)</li>
  <li>메모리를 활용하면서 영속적인 데이터 보존</li>
  <li>스냅샷 기능을 제공하여 메모리의 내용을 *.rdb파일로 저장하여 해당 시점으로 복구 할 수 있다.</li>
  <li>명령어를 이용하여 명시적 삭제 혹은 만료일을 설정하지 않으면 데이터가 삭제 되지 않는다.</li>
  <li>Redis는 1개의 싱글 스레드로 수행됨. 따라서 서버하나에 여러 개의 Redis서버를 띄우는 것이 가능 .</li>
  <li>Master - slave 형식으로 구성하여 데이터 분실위험을 없앨 수 있다.
Mongo vs Redis</li>
  <li>쿼리를 많이 사용하는 프로젝트 Mongo</li>
  <li>속도가 제일 우선 -Redis</li>
</ul>

<p>Redis 세션 저장</p>

<ul>
  <li>node에서 redis를 사용하지 않고 express-session만을 사용하여 데이터를 저장하고 있다면 서버를 재시작하는 순간 저장했던 내용들이 날아가게 됨.
서버를 재시작하고도 데이터를 유지하고 싶다면? 데이터베이스를 사용해서 데이터를 유지하는 것. 하지만 MySql, Mongodb와 같은 데이터베이스에 저장하는 것은 비용과 속도가 느림.
이때 사용하는 것이 Redis - 메모리를 이용하기 때문에 속도가 매우 빠름. 노드 클러스링 시 pid가 달라 세션이 유지되지 않는 문제도 레디스를 통해 세션 공유하여 해결.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[JavaScript] 공부 (정리전)</title>
	  <link>//javascript-interview01</link>
	  <author></author>
	  <pubDate>2019-03-03T09:00:00+09:00</pubDate>
	  <guid>//javascript-interview01</guid>
	  <description><![CDATA[
	     <p>Es6</p>

<ul>
  <li>let, const 도입
const와 let은 블록 스코프를 따름
기존 var는 함수 스코프</li>
  <li>let, const도입으로 호이스팅이 일어나지 않는다.
호이스팅이란? 변수의 정의가 선언과 할당으로 분리되어 변수의 선언을 항상 컨텍스트 내의 최상위로 끌어올리는 것을 의미.</li>
  <li>const : 한번초기화하면 재할당이 불가능, 재선언도 불가능</li>
  <li>let : 재할당 가능 재선언 불가능</li>
</ul>

<p>Template Literals
기존</p>

<p>변경</p>

<p>렉시컬 스코프(정적 스코프)</p>

<ul>
  <li>소스코드가 작성된 그 문맥에서 결정되는 스코프</li>
  <li>스코프는 함수를 호출할 때 생기는 것이 아니라 선언할 때 생김.</li>
</ul>

<p>클로저</p>

<ul>
  <li>내부함수가 외부함수의 지역변수의 접근할 수 있고, 외부함수는 외부함수의 지역변수를 사용하는 내부함수가 소멸될 때까지 소멸 되지 않는 특성을 의미한다.</li>
</ul>

<p>스코프체인</p>

<ul>
  <li>변수가 호출되었을 때 자신의 스코프부터 찾고 없으면 점점 올라가서 상위 스코프에서 찾는 것을말한다.</li>
  <li>내부함수에서는 외부함수의 변수에 접근 가능하지만 외부함수에서는 내부함수의 변수에 접근할 수 없다.</li>
</ul>

<p>Exports module.exports require 차이</p>

<ul>
  <li>require는 module을 import할 때 사용한다. 반환 값은 module.exports이다.
모듈이란?
관련된 코드들을 하나의 코드 단위로 캡슐화하는 것.</li>
  <li>exports는 module.exports를 참조하고 있다.
그래서 사용할 때 exports는 객체에 프로퍼티를 추가해서 사용해야하고 module.exports는 변수에 새로운 객체를 할당한다.</li>
</ul>

<p>Es6
화살표 함수에는 없는 것 : 함수이름 , this, arguments</p>

<p>Promise 객체란</p>

<ul>
  <li>비동기 동작이 완료된 이후 성공, 실패 결과를 처리하기 위한 핸들러입니다. 값을 가져오게되면 어떻게 처리를 해주겠다는 일종의 약속</li>
  <li>callback함수를 실행하는 대신에 객체로 사용하는 것이다.</li>
</ul>

<p>Async await란?
Es8(ecma2017)의 공식정의된 문법으로 async, await를 사용하면 비동기 코드를 작성할 때 비교적 쉽고 명확하게 코드를 작성할 수 있따.</p>

<p>자바스크립트는 싱글스레드 프로그래밍언어이기 떄문에 비동기 처리가 필수적입니다. 비동기 처리는 그 결과가 언제 반환될지 알 수 없기 떄문에 동기식으로 처리하는 기법들이 사용되어야하는데 이 때 사용하는 것이 callback, promise, (async, await)입니다.</p>

<p>callback은 많은 callback함수들이 중첩되면 코드의 가독성이 떨어지게됩니다. 이 문제점을 해결하기 위해 promise 개념이 등장합니다. 그 이후 더 절차적이게 보이는 async await 개념이 등장합니다. 주의할 점은 await 뒷부분은 반드시 promise객체를 반환해야한다는 것과 async 함수 자체도 promise를 반환한다는 것입니다.</p>

<p>Await <expression></expression></p>

<ul>
  <li>await 키워드 오른쪽의 표현식은 Promise.resolve()로 감싸여 항상 Promise객체로 간주된다.</li>
  <li>async 함수는 항상 Promise를 리턴하며, 그 성공값은 리턴값과 같다.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function foo() {
    if (true) {
        var name = 'hans';
    }
    console.log(name); // hans
}
foo();
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>function foo() {
    if (true) {
        const name = 'hans';
    }
    console.log(name); // Uncaught ReferenceError : name is not defined
}
foo();
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = 3;
var first = 'jeong';
var last = 'pro';
var string = a + 'my name is ' + first + ' ' + last; // '3my name is jeong pro
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var a = 3;
var first = 'jeong';
var last = 'pro';
const string = `${a}my name is ${first} ${last}`;
Var a =10;
Function foo() {
 Var b= 10;
 Console.log(a) //10
 Console.log(b) //10
}
Console.log(b) //undefined
</code></pre></div></div>

<p>기존</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Const func1 = function() {
  Console.log(arguments);
}
Func(1,2,3,4)
</code></pre></div></div>

<p>Es6</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Const func1 = (…args) =&gt; {
   Consle.log(args)
}
Func1(1,2,3,4)
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>[React] 컴포넌트간의 데이터 전송</title>
	  <link>//react-data-transfer</link>
	  <author></author>
	  <pubDate>2019-03-01T09:00:00+09:00</pubDate>
	  <guid>//react-data-transfer</guid>
	  <description><![CDATA[
	     <p>2개이상의 컴포넌트를 만들게 되면 부모 자식 관계의 컴포넌트가 생성되게 됩니다.<br />
리액트에서 컴포넌트간 데이터를 전송을 해야하는 경우가 많습니다. 이럴때 어떻게 데이터를 전송할 수 있을지 알아보도록하겠습니다.</p>

<blockquote>
  <ol>
    <li>부모에서 자식으로 데이터 전송</li>
    <li>자식에서 부모로 데이터 전송</li>
  </ol>
</blockquote>

<h2 id="1-부모컴포넌트에서-자식컴포넌트로-데이터-전송">1. 부모컴포넌트에서 자식컴포넌트로 데이터 전송</h2>

<p>부모에서 자식으로 데이터를 전송하는 방법은 Props를 이용한 방식을 사용합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Parent extends Component {
    const data = this.state.data;
    render() {
        return (
            &lt;div&gt;
                &lt;Child dataFromParent={data} /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">Parent</code> 컴포넌트에서 자식컴포넌트를 렌더링하고있는 상황에 부모컴포넌트는 data라는 값을 자식컴포넌트 dataFromParent로 전달해줍니다.<br />
이때 <code class="highlighter-rouge">Child</code> 컴포넌트에서는 this.props.dataFromParent로 접근하여 데이터를 읽을 수 있습니다.</p>

<h2 id="2-자식컴포넌트에서-부모컴포넌트로-데이터-전송">2. 자식컴포넌트에서 부모컴포넌트로 데이터 전송</h2>

<p>자식에서 부모로 데이터를 전송하는 방법은 states를 이용한 방식을 사용합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Parent extends Component {
    parentCallback = (dataFromChild) =&gt; {
        // 자식 컴포넌트에서 받은 값을 이용한 로직 처리
        this.setState({
            data: dataFromChild
        })
    }

    render() {
        return (
            &lt;div&gt;
                &lt;Child callbackFromParent={this.parentCallback}&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre></div></div>

<p>위와 같이 parentCallback 함수를 <code class="highlighter-rouge">Child</code>에게 전달하여 자식은 this.props.callbackFromParent로 접근 할 수 있습니다. 접근하여 <code class="highlighter-rouge">Parent</code> state값을 변경할 수 있습니다.</p>

<p>1, 2번 부모가 인자를 넘겨주고 자식이 이용하는 방법은 동일하지만 부모가 자식에게 데이터를 전달하는 것은 자식컴포넌트에서 부모컴포넌트의 데이터를 이용한(읽기) 로직을 처리하기 위함이고, 자식 컴포넌트에서 부모컴포넌트로 데이터를 전달하는 것은 부모 state의 값을 변경하기 위함입니다.</p>

<p>간단하게 부모와자식컴포넌트 사이에서 데이터를 교환하는 방법에대해서 알아보았습니다.</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>[React] LifeCycle</title>
	  <link>//react-lifecycle</link>
	  <author></author>
	  <pubDate>2019-02-28T09:00:00+09:00</pubDate>
	  <guid>//react-lifecycle</guid>
	  <description><![CDATA[
	     <p>면접을 준비하면서 리액트를 빠르게 배워서 개발을 진행했습니다.<br />
공부하면서 중요한 부분중에 하나가 역시 LifeCycle이었고 어려운 부분이었습니다.</p>

<p>어떠한 내용들이 있는지 정리하는 포스팅을 해보려고 합니다.</p>

<h2 id="생성">생성</h2>

<hr />

<h3 id="1constructor">1.constructor</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constructor(props) {
    super(props);
}
</code></pre></div></div>

<p>constructor는 생성자 메소드로 컴포넌트가 처음 생성될떄 만들어집니다.
props또한 전달되어집니다.</p>

<h3 id="2componentwillmount-deprecated">2.componentWillMount (deprecated)</h3>

<h3 id="3-render">3. render</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>render {
    return()
}
</code></pre></div></div>

<p>리액트를 하시면 위와 같은 코드를 보실 수 있는데요 jsx문법을 사용하여 렌더링하는 부분입니다.</p>

<h3 id="4-componentdidmount">4. componentDidMount</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentDidMount() {
    Document.get...
    axios.get...
}
</code></pre></div></div>

<p>componentDidMount는 3번 render이후에 즉 컴포넌트가 렌더링된 이후 호출되는 메소드로 DOM 조작 및 axios등을 이용한 비동기 데이터 요청을 주로 작성하는 부분입니다.<br />
여기서 주의할점은 componentDidMount 메소드에서 setState를 이용하여 state의 값을 변경하게되면 리렌더링이 되므로 작성하지 않는 것이 좋습니다.</p>

<h2 id="업데이트">업데이트</h2>

<hr />

<h3 id="1-getderivedstatefromprops">1. getDerivedStateFromProps</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.val !== nextProps.val) {
        return {val: nextProps.val};
    }
    return null;
}
</code></pre></div></div>

<p>getDerivedStateFromProps는 Props가 변할때 state값을 변경해서 리렌링 할 수 있는 메소드입니다.<br />
위와 같이 기본적으로 null을 리턴하며 이전 state의 값과 이후 받은 props의 값을 비교하여 다른 경우에만
state를 변경시켜주는 코드입니다. 여기서 주의하실점은 setState문을 이용하여 state를 변경하는 것이아니라
retrun {val: nextProps.val}의 형태로 반환해준다는 것입니다.</p>

<h3 id="2-shouldcomponentupdate">2. shouldComponentUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shouldComponentUpdate(nextProps, nextState) {
    if ( this.state.val !== nextState.val) {
        return false;
    }
    return true;
}
</code></pre></div></div>

<p>기본적으로 return하는 값은 true이며 true인경우에는 리렌더링을 진행합니다.<br />
해당 메소드는 성능 최적화를 하기위해서 사용하는 메소드로 굳이 리렌더링을 하지 않아도 되는 state를 막는 것입니다.<br />
위와같이 state혹은 Props를 비교해서 값이 변경된 경우에만 렌더링을 하게 할 수 있습니다.</p>

<h3 id="3-getsnapshotbeforeupdate">3. getSnapshotBeforeUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getSnapshotBeforeUpdate(prevProps, prevState) {
    return prevState.val;
}
</code></pre></div></div>

<p>해당 메소드는 수정(update)이 발생하기 바로 전에 호출되는 메소드입니다. 해당 메소드에서 반환한 값은
componentDidupdate에 세번째 매개변수로 전달됩니다. (자주 사용하는 부분은 아닌것같습니다.)<br />
찾아보니 리렌더링되는 동안 스크롤의 위치가 처음으로초기화 되는 것이아니라 기존의 위치로 렌더링되기위해 기존의 위치를 update되기전 넘겨주는 역할을 하는 경우에 사용한다고 합니다.</p>

<h3 id="4-componentdidupdate">4. componentDidUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentDidUpdate(prevProps, prevState, [snapshot]) {
}
</code></pre></div></div>

<p>해당 메소드는 업데이트 처리를 끝내고 render이 된 이후에 실행되는 메소드입니다.<br />
즉 모든 props와 state의 값이 변경이된상태이고 prevProps와 prevState 인자를 이용해 이전의 값들은 읽을 수 있습니다.<br />
또한 세번째 인자인 snapshot은 3번에 getSnapshotBeforeUpdate에서 반환한 데이터입니다.</p>

<h2 id="소멸">소멸</h2>

<hr />

<h3 id="1-componentwillunmount">1. componentWillUnmount</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentWillUnmount() {
}
</code></pre></div></div>

<p>해당 메소드는 컴포넌트가 소멸될때 발생하는 메소드로 인스턴스를 제거하는 코드를 작섷해줍니다.</p>

<p>여기까지 큰틀로 실행되는 리액트의 LifeCycle에대해서 알아보았습니다.<br />
deprecated 된것이 꽤 있기 때문에 모든것을 적지는 않았습니다.</p>

<p>저 또한 작성하면서 다시 공부할 수 있었습니다.</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>


</channel>
</rss>
