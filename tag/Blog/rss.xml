<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>ghwlchlaks.github.io/</title>
   
   <link>https://ghwlchlaks.github.io</link>
   <description>같이 배워가는 IT 블로그입니다~. Python, JavaScript, nodejs, Github, algorithm, etc</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[React] 컴포넌트간의 데이터 전송</title>
	  <link>//react-data-transfer</link>
	  <author></author>
	  <pubDate>2019-03-01T09:00:00+09:00</pubDate>
	  <guid>//react-data-transfer</guid>
	  <description><![CDATA[
	     <p>2개이상의 컴포넌트를 만들게 되면 부모 자식 관계의 컴포넌트가 생성되게 됩니다.<br />
리액트에서 컴포넌트간 데이터를 전송을 해야하는 경우가 많습니다. 이럴때 어떻게 데이터를 전송할 수 있을지 알아보도록하겠습니다.</p>

<blockquote>
  <ol>
    <li>부모에서 자식으로 데이터 전송</li>
    <li>자식에서 부모로 데이터 전송</li>
  </ol>
</blockquote>

<h2 id="1-부모컴포넌트에서-자식컴포넌트로-데이터-전송">1. 부모컴포넌트에서 자식컴포넌트로 데이터 전송</h2>

<p>부모에서 자식으로 데이터를 전송하는 방법은 Props를 이용한 방식을 사용합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Parent extends Component {
    const data = this.state.data;
    render() {
        return (
            &lt;div&gt;
                &lt;Child dataFromParent={data} /&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre></div></div>

<p>위와 같이 <code class="highlighter-rouge">Parent</code> 컴포넌트에서 자식컴포넌트를 렌더링하고있는 상황에 부모컴포넌트는 data라는 값을 자식컴포넌트 dataFromParent로 전달해줍니다.<br />
이때 <code class="highlighter-rouge">Child</code> 컴포넌트에서는 this.props.dataFromParent로 접근하여 데이터를 읽을 수 있습니다.</p>

<h2 id="2-자식컴포넌트에서-부모컴포넌트로-데이터-전송">2. 자식컴포넌트에서 부모컴포넌트로 데이터 전송</h2>

<p>자식에서 부모로 데이터를 전송하는 방법은 states를 이용한 방식을 사용합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Parent extends Component {
    parentCallback = (dataFromChild) =&gt; {
        // 자식 컴포넌트에서 받은 값을 이용한 로직 처리
        this.setState({
            data: dataFromChild
        })
    }

    render() {
        return (
            &lt;div&gt;
                &lt;Child callbackFromParent={this.parentCallback}&gt;
            &lt;/div&gt;
        )
    }
}
</code></pre></div></div>

<p>위와 같이 parentCallback 함수를 <code class="highlighter-rouge">Child</code>에게 전달하여 자식은 this.props.callbackFromParent로 접근 할 수 있습니다. 접근하여 <code class="highlighter-rouge">Parent</code> state값을 변경할 수 있습니다.</p>

<p>1, 2번 부모가 인자를 넘겨주고 자식이 이용하는 방법은 동일하지만 부모가 자식에게 데이터를 전달하는 것은 자식컴포넌트에서 부모컴포넌트의 데이터를 이용한(읽기) 로직을 처리하기 위함이고, 자식 컴포넌트에서 부모컴포넌트로 데이터를 전달하는 것은 부모 state의 값을 변경하기 위함입니다.</p>

<p>간단하게 부모와자식컴포넌트 사이에서 데이터를 교환하는 방법에대해서 알아보았습니다.</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>[React] LifeCycle</title>
	  <link>//react-lifecycle</link>
	  <author></author>
	  <pubDate>2019-02-28T09:00:00+09:00</pubDate>
	  <guid>//react-lifecycle</guid>
	  <description><![CDATA[
	     <p>면접을 준비하면서 리액트를 빠르게 배워서 개발을 진행했습니다.<br />
공부하면서 중요한 부분중에 하나가 역시 LifeCycle이었고 어려운 부분이었습니다.</p>

<p>어떠한 내용들이 있는지 정리하는 포스팅을 해보려고 합니다.</p>

<h2 id="생성">생성</h2>

<hr />

<h3 id="1constructor">1.constructor</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>constructor(props) {
    super(props);
}
</code></pre></div></div>

<p>constructor는 생성자 메소드로 컴포넌트가 처음 생성될떄 만들어집니다.
props또한 전달되어집니다.</p>

<h3 id="2componentwillmount-deprecated">2.componentWillMount (deprecated)</h3>

<h3 id="3-render">3. render</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>render {
    return()
}
</code></pre></div></div>

<p>리액트를 하시면 위와 같은 코드를 보실 수 있는데요 jsx문법을 사용하여 렌더링하는 부분입니다.</p>

<h3 id="4-componentdidmount">4. componentDidMount</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentDidMount() {
    Document.get...
    axios.get...
}
</code></pre></div></div>

<p>componentDidMount는 3번 render이후에 즉 컴포넌트가 렌더링된 이후 호출되는 메소드로 DOM 조작 및 axios등을 이용한 비동기 데이터 요청을 주로 작성하는 부분입니다.<br />
여기서 주의할점은 componentDidMount 메소드에서 setState를 이용하여 state의 값을 변경하게되면 리렌더링이 되므로 작성하지 않는 것이 좋습니다.</p>

<h2 id="업데이트">업데이트</h2>

<hr />

<h3 id="1-getderivedstatefromprops">1. getDerivedStateFromProps</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static getDerivedStateFromProps(nextProps, prevState) {
    if (prevState.val !== nextProps.val) {
        return {val: nextProps.val};
    }
    return null;
}
</code></pre></div></div>

<p>getDerivedStateFromProps는 Props가 변할때 state값을 변경해서 리렌링 할 수 있는 메소드입니다.<br />
위와 같이 기본적으로 null을 리턴하며 이전 state의 값과 이후 받은 props의 값을 비교하여 다른 경우에만
state를 변경시켜주는 코드입니다. 여기서 주의하실점은 setState문을 이용하여 state를 변경하는 것이아니라
retrun {val: nextProps.val}의 형태로 반환해준다는 것입니다.</p>

<h3 id="2-shouldcomponentupdate">2. shouldComponentUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shouldComponentUpdate(nextProps, nextState) {
    if ( this.state.val !== nextState.val) {
        return false;
    }
    return true;
}
</code></pre></div></div>

<p>기본적으로 return하는 값은 true이며 true인경우에는 리렌더링을 진행합니다.<br />
해당 메소드는 성능 최적화를 하기위해서 사용하는 메소드로 굳이 리렌더링을 하지 않아도 되는 state를 막는 것입니다.<br />
위와같이 state혹은 Props를 비교해서 값이 변경된 경우에만 렌더링을 하게 할 수 있습니다.</p>

<h3 id="3-getsnapshotbeforeupdate">3. getSnapshotBeforeUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getSnapshotBeforeUpdate(prevProps, prevState) {
    return prevState.val;
}
</code></pre></div></div>

<p>해당 메소드는 수정(update)이 발생하기 바로 전에 호출되는 메소드입니다. 해당 메소드에서 반환한 값은
componentDidupdate에 세번째 매개변수로 전달됩니다. (자주 사용하는 부분은 아닌것같습니다.)<br />
찾아보니 리렌더링되는 동안 스크롤의 위치가 처음으로초기화 되는 것이아니라 기존의 위치로 렌더링되기위해 기존의 위치를 update되기전 넘겨주는 역할을 하는 경우에 사용한다고 합니다.</p>

<h3 id="4-componentdidupdate">4. componentDidUpdate</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentDidUpdate(prevProps, prevState, [snapshot]) {
}
</code></pre></div></div>

<p>해당 메소드는 업데이트 처리를 끝내고 render이 된 이후에 실행되는 메소드입니다.<br />
즉 모든 props와 state의 값이 변경이된상태이고 prevProps와 prevState 인자를 이용해 이전의 값들은 읽을 수 있습니다.<br />
또한 세번째 인자인 snapshot은 3번에 getSnapshotBeforeUpdate에서 반환한 데이터입니다.</p>

<h2 id="소멸">소멸</h2>

<hr />

<h3 id="1-componentwillunmount">1. componentWillUnmount</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>componentWillUnmount() {
}
</code></pre></div></div>

<p>해당 메소드는 컴포넌트가 소멸될때 발생하는 메소드로 인스턴스를 제거하는 코드를 작섷해줍니다.</p>

<p>여기까지 큰틀로 실행되는 리액트의 LifeCycle에대해서 알아보았습니다.<br />
deprecated 된것이 꽤 있기 때문에 모든것을 적지는 않았습니다.</p>

<p>저 또한 작성하면서 다시 공부할 수 있었습니다.</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>취업 미션 후기</title>
	  <link>//interview-review01</link>
	  <author></author>
	  <pubDate>2019-02-27T09:00:00+09:00</pubDate>
	  <guid>//interview-review01</guid>
	  <description><![CDATA[
	     <h1 id="2주-동안-미션-진행-결과는-탈락">2주 동안 미션 진행.. 결과는 탈락..</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>후기 : 취업 쉽지않네요.. 열심히 했다고 생각했는데 실력이 많이 부족했나봅니다..

오늘은 쉬고 내일부터 다시 또 달려야겠습니다 ㅎㅎ
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>NoSQL 공부01</title>
	  <link>//interview03</link>
	  <author></author>
	  <pubDate>2019-02-10T09:00:00+09:00</pubDate>
	  <guid>//interview03</guid>
	  <description><![CDATA[
	     <h2 id="nosql-공부01">NoSQL 공부01</h2>
<p>NoSql은 키-값이나 컬럼, 문서 형식 등의 데이터 모델을 이용, 비 관계형 데이터베이스 
Nosql과 RDBMS와의 다른 점</p>
<ul>
  <li>스키마가 없다. (데이터 관계와 정해진 규격 (table-colmn의 정의))가 없다.</li>
  <li>관계 정의가 없으니 Join이 불가능 (reference(참조)와 같은 기능으로 비슷하게 구현 가능)</li>
  <li>분산처리(수평적 확장)를 쉽게 제공
왜 사용하는가?</li>
  <li>많은 양의 데이터를 효율적으로 처리가 필요할 때</li>
  <li>데이터의 분산처리, 빠른 쓰기가 필요할 떄</li>
  <li>분산처리를 하므로 특정서버에 장애가 발생했을때에도 데이터 유실이나 서비스 중지가 없는 형태의 구조이기 때문에 사용</li>
</ul>

<p>대표적인 Nosql</p>
<ul>
  <li>키-밸류형: redis</li>
  <li>문서형: mongodb</li>
</ul>

<p>Mongodb</p>
<ul>
  <li>문서지향 데이터 베이스 : 내장 문서와 배열을 이용해서 복잡한 계층구조를 하나의 레코드로 표현 할 수 있다.(json, array)</li>
  <li>스키마가 없다. (필드 추가 및 제거가 자유로움)</li>
  <li>RDBMS보다 빠름.</li>
</ul>

<p>Memcached(Remote Dictionary Server)</p>
<ul>
  <li>키-밸류 저장소</li>
  <li>주 사용 사례 : 캐싱, 세션 관리, pub/sub, 순위표  (대형 포털에서는 static page, 검색결과 등을 캐쉬하는데 많이 사용)</li>
  <li>데이터가 메모리에만 저장되므로 빠름 (휘발성)
-프로세스가 죽거나 장비가 종료되면 데이터가 사라짐</li>
  <li>만료가 되지 않더라고 더 이상 메모리에 넣을 용량이 없으면 LRU(Least recently used) 알고리즘에 의해 사라진다. (최근에 가장 적게 사용한 데이터 먼저)</li>
</ul>

<p>Redis와 Memcached의 차이점</p>
<ul>
  <li>Redis는 디스크와 메모리에 저장되는데도 속도가 빠르다.</li>
  <li>데이터가 메모리 디스크에 저장되기 때문에 불의의 경우에도 데이터 복구가 가능.</li>
  <li>저장소 메모리 재사용 없음. 명시적으로만 데이터 제거 가능</li>
  <li>Redis는 문자열 ,Set, Sorted set, Hash, List등 다양한 데이터 타입을 지원하지만 Memcached는 문자열만 지원</li>
</ul>

<p>Redis장점</p>
<ul>
  <li>리스트, 배열과 같은 데이터를 처리하는데 용이</li>
  <li>Mysql에 비해서 속도가 빠르다.</li>
  <li>여러 프로세스에서 동시에 같은 key에 대한 갱신을 요청할 경우, 원자성 처리로 데이터 부적합 방지(원자성 처리 함수 제공)</li>
  <li>메모리를 활용하면서 영속적인 데이터 보존</li>
  <li>스냅샷 기능을 제공하여 메모리의 내용을 *.rdb파일로 저장하여 해당 시점으로 복구 할 수 있다.</li>
  <li>명령어를 이용하여 명시적 삭제 혹은 만료일을 설정하지 않으면 데이터가 삭제 되지 않는다.</li>
  <li>Redis는 1개의 싱글 스레드로 수행됨. 따라서 서버하나에 여러 개의 Redis서버를 띄우는 것이 가능 .</li>
  <li>Master - slave 형식으로 구성하여 데이터 분실위험을 없앨 수 있다. 
Mongo vs Redis</li>
  <li>쿼리를 많이 사용하는 프로젝트 Mongo</li>
  <li>속도가 제일 우선 -Redis</li>
</ul>

<p>Redis 세션 저장</p>
<ul>
  <li>node에서 redis를 사용하지 않고 express-session만을 사용하여 데이터를 저장하고 있다면 서버를 재시작하는 순간 저장했던 내용들이 날아가게 됨. 
서버를 재시작하고도 데이터를 유지하고 싶다면? 데이터베이스를 사용해서 데이터를 유지하는 것. 하지만 MySql, Mongodb와 같은 데이터베이스에 저장하는 것은 비용과 속도가 느림. 
이때 사용하는 것이 Redis - 메모리를 이용하기 때문에 속도가 매우 빠름.  노드 클러스링 시 pid가 달라 세션이 유지되지 않는 문제도 레디스를 통해 세션 공유하여 해결.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>Git 공부01</title>
	  <link>//interview02</link>
	  <author></author>
	  <pubDate>2019-02-09T09:00:00+09:00</pubDate>
	  <guid>//interview02</guid>
	  <description><![CDATA[
	     <h2 id="git-공부01">Git 공부01</h2>
<p>git clone</p>
<ul>
  <li>원격저장소를 복제하여 가져온다.</li>
</ul>

<p>git add</p>
<ul>
  <li>워킹디렉토리에 있는 파일들은 stage영역으로 추가하는 것 . 추가하게되면 commit-을 이용한 스냅샷저장에 포함되어진다.</li>
</ul>

<p>git commit</p>
<ul>
  <li>저장소의 스냅샷을 찍기위한 명령어. 한 개한개가 버전업이되는것이다</li>
</ul>

<p>git branch</p>
<ul>
  <li>메인 브랜치 혹은 작업할 브랜치에서 분기를 하여 작업할 수 있는 공간을 말한다.</li>
</ul>

<p>git checkout</p>
<ul>
  <li>브랜치로 이동혹은 특정 버전(커밋)으로 이동하는 명령어</li>
</ul>

<p>git statsh</p>
<ul>
  <li>unstaged 상태(add하지 않은 상태)인 변경사항을 일시적으로 백업하고 워킹디렉토리를(작업디렉토리)를 깨끗한 상태로 유지(HEAD) 상태로</li>
  <li>그 후 rebase나 pull값은 작업을 할 수 있음</li>
  <li>그 후 git statsh pop or git stash apply를 사용하여 워킹디렉토리에 백업한 내용을 적용할 수 있습니다.</li>
</ul>

<p>git push</p>
<ul>
  <li>로컬저장소에 저장된 (add, commit이된) 파일들을 원격저장소에 업로드한다.</li>
</ul>

<p>git merge</p>
<ul>
  <li>브랜치를 합친다.</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>웹 공부01</title>
	  <link>//interview01</link>
	  <author></author>
	  <pubDate>2019-02-08T09:00:00+09:00</pubDate>
	  <guid>//interview01</guid>
	  <description><![CDATA[
	     <h2 id="웹-공부01">웹 공부01</h2>
<p>Fetch api를 이용하면 request나 response와 같은 HTTP의 파이프라인을 구성하는 요소를 조작하는 것이 가능.
XMLHttpRequest 객체를 사용해 서버와 상호작용을 살 수 있습니다. 페이지 전체의 데이터를 새로 받아오지 않고도 특정 URL로부터 데이터를 받아 올 수 있습니다. 이를 이용해 웹페이지는 용자를 방해하지 않고도 페이지의 일부분만을 업데이트 할 수 있습니다.</p>

<p>Fetch vs axios</p>
<ul>
  <li>fetch api 는 간편하게 사용이 가능하지만 요청 취소가 불가능하다는 점이 있습니다.</li>
</ul>

<p>GET - 요청받은 URI의 정보를 검색하여 응답 (READ)
HEAD - 응답코드와 HEAD만 응답한다. (웹서버 정보확인, 헬스 체크, 버전확인, 최종 수정일자 확인등의 용도)
POST - 요청된 자원을 생성한다. (CREAT)
PUT - 요청된 자원을 수정한다. (전체 UPDATE)
PATCH - 요청된 자원을 수정(일부분 UPDATE)
DELETE - 요청된 자원을 삭제할 것을 요청(DELETE)</p>

<p>응답코드 
200 - 성공
300 - 리다이렉션
400 - 클라이언트 요청 실패 
500 - 서버 에러</p>

<p>Html doctype</p>
<ul>
  <li>해당 소스를 읽을 때 웹문서가 html5로 작성되었음을 알려준다. 웹페이지 문서 종류를 알려주는 선언문 웹페이지 제일 처음에 선언되어야하는 것</li>
</ul>

<p>이벤트 버블링</p>
<ul>
  <li>특정 화면 요소에서 이벤트가 발생했을 때 해당 이벤트가 더 상위의 화면 요소들로 전달되어 가는 특성을 의미</li>
</ul>

<p>이벤트 캡처</p>
<ul>
  <li>버블링과는 반대되는 개념으로 이벤트가 발생했을떄 해당 이벤트가 하위의 화면 요소로 전달되어가는 특성을 의미 (옵션으로 capture: true를 설정)
.
이벤트 위임 
-이벤트 캡처, 이벤트버블링을 이용한 방법으로 리스트가 동적으로 추가되는 상황에 이벤트를 매번 추가하는 번거로움을 상위 태그에 이벤트를 지정하여 처리하는 것</li>
</ul>

<p>http</p>
<ul>
  <li>인터넷상에서 정보를 주고받기위한 프로토콜</li>
  <li>클라이언트와 서버사이에 이루어치는 프로토콜 
https</li>
  <li>모든 http 요청과 응답데이터는 네트워크로 보내지기전에 암호화된다.</li>
  <li>https는 http의 하부에 ssl과 같은 보안 계층을 제공함으로써 동작
Ssl 디지털 인증서</li>
  <li>클라이언트와 서버간의 통신을 제 3자가 보증해주는 전자화된 문서
인증과정</li>
  <li>클라이언트가 서버에 요청한 직후에 서버는 클라이언트에게 인증서정보를 전달</li>
  <li>클라이언트는 신뢰할수 있는 서버인지 확인</li>
  <li>클라이언트 공개키 방식으로 암호화해서 서버에게 전달</li>
  <li>서버는 비공개키로 복호화하여 서버와 클라이언트가 세션키를 공유</li>
  <li>데이터 교환</li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>[Angular] Angular Http Ajax 사용하기</title>
	  <link>//angular-http</link>
	  <author></author>
	  <pubDate>2019-01-27T09:00:00+09:00</pubDate>
	  <guid>//angular-http</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 입니다.</p>

<p>이번에 포스팅할 내용은 Angular에서 http 방법으로 Api 호출하는 방법에대해서 포스팅하겠습니다.</p>

<h2 id="순서">순서</h2>
<blockquote>
  <ul>
    <li>라이브러리 설치</li>
    <li>service 파일 생성</li>
    <li>module 파일 수정</li>
    <li>service 파일 수정</li>
    <li>사용</li>
  </ul>
</blockquote>

<p><strong>1. 라이브러리 설치</strong><br />
http 라이브러리를 사용하기위해 아래 명령어를 이용하여 설치 해줍니다. 
기본적으로 @angular라이브러리들은 설치가 되있겠지만 혹시 설치가 안되있는경우 설치해 줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">npm</span> <span class="n">install</span> <span class="vi">@angular</span><span class="o">/</span><span class="n">http</span>
<span class="n">npm</span> <span class="n">install</span> <span class="n">rxjs</span><span class="o">-</span><span class="n">compat</span> </code></pre></figure>

<p><strong>2. service 파일 생성</strong><br />
http 라이브러리를 관리하기위해 파일을 생성해줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">ng</span> <span class="n">generate</span> <span class="n">service</span> <span class="n">services</span><span class="o">/</span><span class="err">파일이름</span></code></pre></figure>

<p><strong>3. module 파일 수정</strong><br />
app.module혹은 컴포넌트에 상위에서 사용하는 module 파일을 수정해 줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">import</span> <span class="p">{</span><span class="no">HttpModule</span><span class="p">}</span> <span class="n">from</span> <span class="s1">'@angular/http'</span><span class="p">;</span>     
<span class="n">import</span> <span class="p">{</span><span class="no">ApiService</span><span class="p">}</span> <span class="n">from</span> <span class="s1">'../services/service파일이름'</span>
<span class="ss">imports: </span><span class="p">[</span><span class="no">HttpModule</span><span class="p">]</span>  
<span class="ss">providers: </span><span class="p">[</span><span class="no">ApiSerice</span><span class="p">]</span></code></pre></figure>

<p><strong>4. service 파일 수정</strong><br />
2번에서 생성한 service파일을 수정해줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">export</span> <span class="k">class</span> <span class="nc">HomeModule</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">import</span> <span class="p">{</span> <span class="no">Injectable</span> <span class="p">}</span> <span class="n">from</span> <span class="s1">'@angular/core'</span><span class="p">;</span>
<span class="n">import</span> <span class="p">{</span><span class="no">Http</span><span class="p">}</span> <span class="n">from</span> <span class="s1">'@angular/http'</span><span class="p">;(</span><span class="err">추가</span><span class="p">)</span>
<span class="vi">@Injectable</span><span class="p">({</span>
<span class="ss">providedIn: </span><span class="s1">'root'</span>
<span class="p">})</span>
<span class="n">export</span> <span class="k">class</span> <span class="nc">ApiService</span> <span class="p">{</span>
<span class="n">constructor</span><span class="p">(</span><span class="kp">private</span> <span class="ss">http: </span><span class="no">Http</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="n">getIpAddress</span><span class="p">():</span> <span class="no">Observable</span><span class="o">&lt;</span><span class="no">Object</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="err">추가</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">this</span><span class="p">.</span><span class="nf">http</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="s1">'localhost:3000/'</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">map</span><span class="p">((</span><span class="ss">data: </span><span class="no">Response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">data</span><span class="p">.</span><span class="nf">json</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><strong>5. 사용</strong><br />
Api를 사용할 컴포넌트 파일을 수정해줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"> 
<span class="n">import</span> <span class="p">{</span><span class="no">ApiService</span><span class="p">}</span> <span class="n">from</span> <span class="s1">'./services/service파일이름'</span>
<span class="n">constructor</span><span class="p">(</span> <span class="kp">private</span> <span class="ss">apiSerivce: </span><span class="no">ApiService</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> 
<span class="n">apiService</span><span class="p">.</span><span class="nf">getData</span><span class="p">().</span><span class="nf">subscribe</span><span class="p">((</span><span class="n">result</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">})</span></code></pre></figure>

<p>위와같이 작성하게되면 localhost:3000으로 api요청이 들어와 값이 반환되게됩니다.<br />
물론 3000포트의 서버는 작성이 되있으셔야겠죠??</p>

<p>지금까지 <strong>Angular Http Ajax 사용하기</strong>이라는 주제로 포스팅하였습니다!</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[도커] 도커파일 Typescript node App에 도커파일 만들기</title>
	  <link>//dockerfile-node-typescript</link>
	  <author></author>
	  <pubDate>2019-01-24T09:00:00+09:00</pubDate>
	  <guid>//dockerfile-node-typescript</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 입니다.</p>

<p>이번에 포스팅할 내용은 도커 파일을 작성하여 자신이 개발한 Typescript용 node를 이미지로 만드는 방법에대해서 포스팅하겠습니다.</p>

<p>먼저 Dockerfile에 명령어가 알고싶다면 <a href="https://ghwlchlaks.github.io/dockerfile-instruction">링크</a> 를 클릭해주세요!</p>

<p><strong>Dockerfile</strong><br />
Dockerfile을 자신이 개발한 앱폴더안에 넣어 작성합니다.<br />
아래방법은 예시방법중 하나입니다. 자신의 개발한 환경에 맞게 작성해주셔야합니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">FROM</span> <span class="n">node</span><span class="ss">:version</span>
<span class="c1"># 특정 버전 node 이미지를 받아옵니다.  </span>
<span class="no">MAINTAINER</span> <span class="n">choi</span>
<span class="c1"># 작성자의 이름을 적습니다. </span>
<span class="no">WORKDIR</span> <span class="sr">/app
# 만들 이미지에 작업할 디렉토리로 이동합니다.  
COPY package*.json /</span><span class="n">app</span><span class="o">/</span>
<span class="c1"># 현재 디렉토리에 package로 시작하는 파일들을 복사하여 이미지에서 작업할 디렉토리로 복사합니다. </span>
<span class="no">RUN</span> <span class="n">npm</span> <span class="n">install</span>
<span class="c1"># 이미지 디렉토리에서 npm install 명령어를 실행해 줍니다. </span>
<span class="c1"># package.json이 있으므로 npm install로 종속 모듈이 설치가 되겠죠?  </span>
<span class="no">RUN</span> <span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">typescript</span>
<span class="c1"># typescript를 이용한 node이므로 전역옵션을 이용하여 typescript 모듈을 설치해줍니다.  </span>
<span class="no">COPY</span> <span class="p">.</span><span class="nf">/</span> <span class="sr">/app/</span>
<span class="c1"># 현재 폴더에 있는 모든 파일들을 복사하여 이미지 디렉토리에 복사합니다. </span>
<span class="c1"># 여기과정이 자신이 작성한 코드등 리소스들이 복사됩니다.  </span>
<span class="no">RUN</span> <span class="n">npm</span> <span class="n">run</span> <span class="n">build</span><span class="o">-</span><span class="n">ts</span>
<span class="c1"># typescript로 작성된 node이므로 build를 하여 javascript 파일로 컴파일 해줍니다.  </span>
<span class="no">CMD</span> <span class="p">[</span><span class="s2">"npm"</span><span class="p">,</span> <span class="s2">"run"</span><span class="p">,</span> <span class="s2">"serve"</span><span class="p">]</span> 
<span class="c1"># 해당 이미지가 실행될때 실행될 명령어입니다. </span>
<span class="c1"># 해당 이미지를 컨테이너로 실행할때 npm run serve 명령어가 실행되어 자신이 작성한 코드에 node가 실행됩니다.                      </span></code></pre></figure>

<p>지금까지 <strong>Typescript node App에 도커파일 만들기</strong>이라는 주제로 포스팅하였습니다!</p>

<p>해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[도커] 도커파일 명령어</title>
	  <link>//dockerfile-instruction</link>
	  <author></author>
	  <pubDate>2019-01-23T09:00:00+09:00</pubDate>
	  <guid>//dockerfile-instruction</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 입니다.</p>

<p>이번에 포스팅할 내용은 도커 파일에 사용하는 명령어에대해서 포스팅하겠습니다.
아래 명령어 순서로 포스팅하겠습니다.</p>

<p><strong>순서</strong></p>
<blockquote>
  <ul>
    <li>FROM</li>
    <li>RUN</li>
    <li>EXPOSE</li>
    <li>ENV</li>
    <li>ENTRYPOINT</li>
    <li>CMD</li>
    <li>ADD</li>
    <li>COPY</li>
    <li>WORKDIR</li>
    <li>VOLUME</li>
    <li>USER</li>
    <li>LABEL</li>
    <li>ARG</li>
  </ul>
</blockquote>

<p><strong>1. FROM</strong><br />
<code class="highlighter-rouge">FROM</code> 명령어는 사용할 이미지를 지정하는 명령어입니다. ubuntu, node와같은 이미지파일을 지정합니다. 지정할때는 <code class="highlighter-rouge">:</code>뒤에 특정 버전을 지정하여 사용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">FROM</span> <span class="n">ubuntu</span><span class="p">:</span><span class="mf">18.04</span>
<span class="n">or</span>
<span class="no">FROM</span> <span class="n">node</span></code></pre></figure>

<p><strong>2. RUN</strong><br />
<code class="highlighter-rouge">RUN</code> 명령어는 내려받은 이미지에 설치할 패키지 또는 shell 명령어를 입력할 수 있습니다. 
예를들어 내려받은 node이미지에 typescript를 설치하는 명령어를 내리고 싶다면</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">RUN</span> <span class="n">npm</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">typescript</span><span class="p">:[</span><span class="n">version</span><span class="p">]</span>
<span class="n">or</span>
<span class="no">RUN</span> <span class="p">[</span><span class="s2">"npm"</span><span class="p">,</span> <span class="s2">"install"</span><span class="p">,</span> <span class="s2">"-g"</span><span class="p">,</span> <span class="s2">"typescript:[version]"</span><span class="p">]</span></code></pre></figure>

<p>보통 apt-get과 같은 명령어를 이용하여 패키지 설치 명령어를 지정해줍니다.</p>

<p><strong>3. EXPOSE</strong><br />
<code class="highlighter-rouge">EXPOSE</code> 명령어는 실행한 container외부에 노출할 포트를 지정하는 명령어입니다.
하지만 container를 실행할때 -p 옵션을통해 연결해주어야한다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">EXPOSE</span> <span class="mi">8080</span></code></pre></figure>

<p><strong>4. ENV</strong> <br />
<code class="highlighter-rouge">ENV</code> 명령어는 환경변수를 지정하는 것으로 파일내부에서 변수처럼 활용이 가능합니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">ENV</span> <span class="nb">test</span> <span class="mi">123</span>
<span class="no">CMD</span> <span class="n">echo</span> <span class="vg">$test</span></code></pre></figure>

<p>해당 도커파일을 빌드하여 실행하면 test변수의 값인 123이 출력되는 것을 확인 할 수 있습니다.
해당 환경변수는 빌드된 이미지를 실행할때 override할 수 있습니다.</p>

<p><strong>5. ENTRYPOINT</strong><br />
<code class="highlighter-rouge">ENTRYPOINT</code> 명령어는 컨테이너를 실행했을때 실행할 명령입니다. 컨테이너를 정지했다가 다시 시작해도 실행하는 명령어입니다. 물론 run명령어로 컨테이너를 실행했을때도 실행됩니다.<br />
컨테이너가 실행될떄 실행되는 명령어이므로 도커파일에서 한번만 사용할 수 있습니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">ENTRYPOINT</span> <span class="p">[</span><span class="s2">"npm"</span><span class="p">,</span> <span class="s2">"run"</span><span class="p">,</span> <span class="s2">"serve"</span><span class="p">]</span></code></pre></figure>

<p><strong>6. CMD</strong><br />
<code class="highlighter-rouge">CMD</code> 명령어는 docker run 실행 시 사용할 default 명령을 설정하는데 사용합니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">CMD</span> <span class="p">[</span><span class="s2">"npm"</span><span class="p">,</span> <span class="s2">"run"</span><span class="p">,</span> <span class="s2">"serve"</span><span class="p">]</span></code></pre></figure>

<p><a href="http://pyrasis.com/book/DockerForTheReallyImpatient/Chapter07/06">ENTRYPOINT와 CMD의 차이</a>를 설명하는 사이트입니다.</p>

<p><strong>7. ADD</strong><br />
<code class="highlighter-rouge">ADD</code> 명령어는 빌드 중 호스트의 디렉토리에서 파일을 가져와서 이미지에 파일을 더하는 것입니다. 
주의할점은 빌드되는 디렉토리 밖에 위치하는 파일들은 가져오지 않습니다.<br />
ADD 호스트파일위치 이미지파일위치</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">ADD</span> <span class="nb">test</span><span class="p">.</span><span class="nf">txt</span> <span class="o">/</span></code></pre></figure>

<p>호스트의 test.txt파일이 이미지 파일에 / 위치로 더해집니다.</p>

<p><strong>8. COPY</strong><br />
<code class="highlighter-rouge">COPY</code> 명령어는 ADD와 동일한 동작을 합니다. 하지만 압축파일을 자동으로 풀어주지 않습니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">COPY</span> <span class="nb">test</span><span class="p">.</span><span class="nf">txt</span> <span class="o">/</span></code></pre></figure>

<p><strong>9. WORKDIR</strong><br />
<code class="highlighter-rouge">WORKDIR</code> 명령어는 cd의 명령어와 비슷합니다. RUN과 CMD과 같은 명령어가 실행될 이미지 내부에 위치를 지정해주는 명령어입니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">WORKDIR</span> <span class="sr">/app/</span></code></pre></figure>

<p><strong>10. VOLUME</strong><br />
<code class="highlighter-rouge">VOLUME</code> 명령어는 호스트의 디렉토리를 docker 컨테이너에 연결하는 명령어입니다. 
여러가지 설정파일, 데이터 등을 docker 컨테이너에너 사용할 수 있게 해줍니다. 
즉 디렉토리 내용을 컨테이너에 저장하지 않고 호스트에 저장하도록 설정하는 것입니다.
로그 수집과 같은 데이터 저장에 쓰임.
VOLUME 호스트디렉토리 컨테이너디렉토리</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">VOLUME</span> <span class="p">[</span><span class="s2">"/data"</span><span class="p">,</span> <span class="s2">"/var/log"</span><span class="p">]</span></code></pre></figure>

<p><strong>11. USER</strong><br />
<code class="highlighter-rouge">USER</code> 명령어는 해당 docker 이미지를 실행할 user를 지정하는 명령어입니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">USER</span> <span class="n">user</span>
<span class="n">or</span>
<span class="no">USER</span> <span class="p">[</span><span class="n">uid</span><span class="p">]:[</span><span class="n">gid</span><span class="p">]</span></code></pre></figure>

<p><strong>12. LABEL</strong><br />
<code class="highlighter-rouge">LABEL</code> 명령어는 이미지에 라벨을 다는 것입니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">LABEL</span> <span class="s2">"abcd@gmail.com"</span></code></pre></figure>

<p><strong>13. ARG</strong><br />
<code class="highlighter-rouge">ARG</code> 명령어는 도커파일 빌드시에 설정하는 옵션들을 지정할 수 있는 명령어 입니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">ARG</span> <span class="n">arg1</span>
<span class="no">ARG</span> <span class="n">arg2</span><span class="o">=</span><span class="n">value</span></code></pre></figure>

<p>위와 같이 지정할 경우 도커파일 빌드시 arg1 인자를 입력받아야합니다. 또한 arg2의 default값은 value값으로 지정되어 빌드된됩니다.</p>

<p>지금까지 <strong>도커파일 명령어</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[리눅스] GUI, CLI 환경으로 변경 방법</title>
	  <link>//linux-gui-to-cli</link>
	  <author></author>
	  <pubDate>2019-01-21T09:00:00+09:00</pubDate>
	  <guid>//linux-gui-to-cli</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 입니다.</p>

<p>이번에 포스팅할 내용은 리눅스 GUI환경에서 CLI환경으로 바꾸는 방법에대해서 포스팅하겠습니다.
바꾸는 방법은 한가지 파일만 수정하면 되므로 쉽습니다.<br />
순서는 아래와 같습니다.</p>

<p><strong>순서</strong></p>
<blockquote>
  <ul>
    <li>주석 처리</li>
    <li>수정</li>
    <li>주석 제거</li>
    <li>CLI 환경 적용</li>
    <li>GUI 환경으로 돌아가기</li>
  </ul>
</blockquote>

<p>이번 포스팅은 /etc/default/grub 파일만을 다룹니다.</p>

<p><strong>1. 주석 처리</strong></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">GRUB_CMDLINE_LINUX_DEFAULT</span> <span class="err">라인을</span> <span class="err">주석처리합니다</span><span class="o">.</span></code></pre></figure>

<p><img src="/assets/images/2019-01-21-linux-gui-to-cli/1.png" /></p>

<p><strong>2. 수정</strong></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">GRUB_CMDLINE_LINUX</span> <span class="err">라인을</span> <span class="no">GRUB_CMDLINE_LINUX</span><span class="o">=</span><span class="s2">"text"</span> <span class="err">로</span> <span class="err">수정합니다</span><span class="o">.</span></code></pre></figure>

<p><img src="/assets/images/2019-01-21-linux-gui-to-cli/2.png" /></p>

<p><strong>3. 주석 제거</strong></p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="p">\</span><span class="c1">#GRUB_TERMINAL=console' 라인에 주석을 제거하여 'GRUB_TERMINAL=console' 로 수정</span></code></pre></figure>

<p><img src="/assets/images/2019-01-21-linux-gui-to-cli/3.png" /></p>

<p>여기까지 파일 수정은 끝이났습니다. :wq명령어 혹은 쓰시는 에디터의 명령어를 이용하여 저장하고 빠져나옵니다.</p>

<p><strong>4. CLI 환경 적용</strong>
아래 명령어를 이용하여 적용해줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">systemctl</span> <span class="n">set</span><span class="o">-</span><span class="n">default</span> <span class="n">multi</span><span class="o">-</span><span class="n">user</span><span class="p">.</span><span class="nf">target</span></code></pre></figure>

<p><img src="/assets/images/2019-01-21-linux-gui-to-cli/5.png" /></p>

<p><strong>4. GUI 환경으로 돌아가기</strong>
혹시나 GUI환경으로 돌아가려면 아래와같은 명령어를 실행해줍니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">systemctl</span> <span class="n">set</span><span class="o">-</span><span class="n">default</span> <span class="n">graphical</span><span class="p">.</span><span class="nf">target</span></code></pre></figure>

<p><img src="/assets/images/2019-01-21-linux-gui-to-cli/4.png" /></p>

<p>이제 모든 설정이 끝이 났습니다. reboot를해서 재부팅을 하면 CLI환경으로 접속되는것을 확인 할 수 있습니다.</p>

<p>지금까지 <strong>GUI, CLI 환경으로 변경 방법</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>


</channel>
</rss>
