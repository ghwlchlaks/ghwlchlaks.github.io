<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>ghwlchlaks.github.io/</title>
   
   <link>https://ghwlchlaks.github.io</link>
   <description>같이 배워가는 IT 블로그입니다~. Python, JavaScript, nodejs, Github, algorithm, etc</description>
   <language>ko-KR</language>
   <managingEditor> </managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>[프로그래머스 LEVEL2] 주식가격 프로그래머스 [파이썬]</title>
	  <link>//stockprice</link>
	  <author></author>
	  <pubDate>2018-10-22T21:00:00+09:00</pubDate>
	  <guid>//stockprice</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong>입니다. ㅎㅎ</p>

<p>이번에 포스팅할 내용은 스택(stack)/큐(queue)와 관련된 <strong>프로그래머스 문제 LEVEL2에 해당되는 주식가격 알고리즘 문제</strong>를 풀어보도록 하겠습니다.</p>

<p>해당 문제는 <a href="https://programmers.co.kr/learn/courses/30/lessons/42584">프로그래머스 웹페이지</a>에서 만나보실 수 있습니다.</p>

<h1 id="문제">문제</h1>
<p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 유지된 기간은 몇 초인지를 계산하는 문제입니다.</p>

<p><strong>제한 사항</strong></p>
<blockquote>
  <ul>
    <li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
    <li>prices의 길이는 2 이상 100,000 이하입니다.</li>
  </ul>
</blockquote>

<h1 id="풀이">풀이</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span><span class="n">prices</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="ss">else:
                </span><span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span></code></pre></figure>

<p>해당 문제는 스택/큐 부분이지만 이중 for문을 이용해서 풀었습니다.<br />
다른 분들이 푸신내용보니깐 큐를 이용해서 (pop(0)) 푸시는 분들도 많았습니다.<br />
사실 저도 큐를 이용하여 접근하였지만 시간초과가 발생해서 간단히 이중for문을 이용했습니다.<br />
시간의 큰차이는 없어보였는데 시간 제한사항이 역시나 민감하네요 
ㅎㅎ 처음에 시간초과가 발생해서 살짝 당황했습니다. ㅎㅎ</p>

<h1 id="풀이방법">풀이방법</h1>
<p>처음 i 변수를 가지는 for문은 비교할 기준의 요소를 정하는 인덱스입니다.<br />
안에 j 변수를 가지는 for문은 인덱스 i부터 끝까지 비교할 대상의 인덱스를 나타냅니다.<br />
안에 <code class="highlighter-rouge">if prices[i] &gt; prices[j]</code>는 기준에 비해 가격이 유지되지 않고 떨어지는 인덱스를 가졌을때 해당 for문을 벗어나는 코드입니다.<br />
<code class="highlighter-rouge">else</code>부분은 이외에는 count를 1씩 증가시켜줍니다.</p>

<p>지금까지 <strong>주식가격 프로그래머스 스택/큐 [파이썬]</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[프로그래머스 LEVEL2] 주식가격 프로그래머스 [파이썬]</title>
	  <link>//Algorithm-stockprice</link>
	  <author></author>
	  <pubDate>2018-10-21T21:00:00+09:00</pubDate>
	  <guid>//Algorithm-stockprice</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong>입니다. ㅎㅎ</p>

<p>이번에 포스팅할 내용은 스택(stack)/큐(queue)와 관련된 <strong>프로그래머스 문제 LEVEL2에 해당되는 주식가격 알고리즘 문제</strong>를 풀어보도록 하겠습니다.</p>

<p>해당 문제는 <a href="https://programmers.co.kr/learn/courses/30/lessons/42584">프로그래머스 웹페이지</a>에서 만나보실 수 있습니다.</p>

<h1 id="문제">문제</h1>
<p>초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 유지된 기간은 몇 초인지를 계산하는 문제입니다.</p>

<p><strong>제한 사항</strong></p>
<blockquote>
  <ul>
    <li>prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.</li>
    <li>prices의 길이는 2 이상 100,000 이하입니다.</li>
  </ul>
</blockquote>

<h1 id="풀이">풀이</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">prices</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">(</span><span class="n">prices</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span><span class="n">prices</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="k">break</span>
            <span class="ss">else:
                </span><span class="n">answer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span></code></pre></figure>

<p>해당 문제는 스택/큐 부분이지만 이중 for문을 이용해서 풀었습니다.<br />
다른 분들이 푸신내용보니깐 큐를 이용해서 (pop(0)) 푸시는 분들도 많았습니다.<br />
사실 저도 큐를 이용하여 접근하였지만 시간초과가 발생해서 간단히 이중for문을 이용했습니다.<br />
시간의 큰차이는 없어보였는데 시간 제한사항이 역시나 민감하네요 
ㅎㅎ 처음에 시간초과가 발생해서 살짝 당황했습니다. ㅎㅎ</p>

<h1 id="풀이방법">풀이방법</h1>
<p>처음 i 변수를 가지는 for문은 비교할 기준의 요소를 정하는 인덱스입니다.<br />
안에 j 변수를 가지는 for문은 인덱스 i부터 끝까지 비교할 대상의 인덱스를 나타냅니다.<br />
안에 <code class="highlighter-rouge">if prices[i] &gt; prices[j]</code>는 기준에 비해 가격이 유지되지 않고 떨어지는 인덱스를 가졌을때 해당 for문을 벗어나는 코드입니다.<br />
<code class="highlighter-rouge">else</code>부분은 이외에는 count를 1씩 증가시켜줍니다.</p>

<p>지금까지 <strong>주식가격 프로그래머스 스택/큐 [파이썬]</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[프로그래머스 LEVEL2] 더맵게 프로그래머스 heap [파이썬]</title>
	  <link>//Algorithm-morespicy</link>
	  <author></author>
	  <pubDate>2018-10-20T21:00:00+09:00</pubDate>
	  <guid>//Algorithm-morespicy</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong>입니다. ㅎㅎ</p>

<p>이번에 포스팅할 내용은 힙(Heap)과 관련된 <strong>프로그래머스 문제 LEVEL2에 해당되는 더맵게 알고리즘 문제</strong>를 풀어보도록 하겠습니다.</p>

<p>해당 문제는 <a href="https://programmers.co.kr/learn/courses/30/lessons/42626">프로그래머스 웹페이지</a>에서 만나보실 수 있습니다.</p>

<h1 id="문제">문제</h1>
<p>매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다.<br />
 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.</p>
<blockquote>
  <p>섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)</p>
</blockquote>

<p><strong>제한 사항</strong></p>
<blockquote>
  <ul>
    <li>scoville의 길이는 1 이상 1,000,000 이하입니다.</li>
    <li>K는 0 이상 1,000,000,000 이하입니다.</li>
    <li>scoville의 원소는 각각 0 이상 1,000,000 이하입니다.</li>
    <li>모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.</li>
  </ul>
</blockquote>

<h1 id="풀이">풀이</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  
<span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">scoville</span><span class="p">,</span> <span class="no">K</span><span class="p">):</span>
    <span class="n">import</span> <span class="n">heapq</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="k">in</span> <span class="ss">scoville:
        </span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="no">K</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">answer</span>
        <span class="n">a</span><span class="o">=</span> <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="n">b</span> <span class="o">=</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">answer</span> <span class="o">+=</span><span class="mi">1</span>    
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></code></pre></figure>

<p>해당 문제는 heapq 모듈을 import하여 해결하였습니다.<br />
heapq를 사용하지 않고 일반 배열에서 queue나 stack방식을 사용한다면 시간초과가 발생하네요.. ㅠㅠ<br />
heapq에대한 설명은 <a href="https://ghwlchlaks.github.io/Heapq-Python/">heapq를 사용해보자 [Python]</a> 에서 볼 수 있습니다. <br />
또한 heapq를 사용하여 다른 알고리즘 문제를 해결한 것은 <a href="https://ghwlchlaks.github.io/Algorithm-Heapq-Python/">이중우선순위큐 알고리즘 [Python]</a>에서 볼 수 있습니다.</p>

<p>지금까지 <strong>더맵게 프로그래머스 heap [파이썬]</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[프로그래머스 LEVEL2] 프린터 프로그래머스 스택/큐 [파이썬]</title>
	  <link>//Algorithm-printer</link>
	  <author></author>
	  <pubDate>2018-10-19T21:00:00+09:00</pubDate>
	  <guid>//Algorithm-printer</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong>입니다. ㅎㅎ</p>

<p>이번에 포스팅할 내용은 스택/큐에 해당되는 <strong>프로그래머스 문제 LEVEL2에 해당되는 프린터 알고리즘 문제</strong>를 풀어보도록 하겠습니다.</p>

<p>해당 문제는 <a href="https://programmers.co.kr/learn/courses/30/lessons/42587">프로그래머스 웹페이지</a>에서 만나보실 수 있습니다.</p>

<h1 id="문제">문제</h1>
<p>일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.</p>
<blockquote>
  <ol>
    <li>인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.</li>
    <li>나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.</li>
    <li>그렇지 않으면 J를 인쇄합니다.</li>
  </ol>
</blockquote>

<p><strong>제한 사항</strong></p>
<blockquote>
  <ul>
    <li>현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.</li>
    <li>인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.</li>
    <li>location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.</li>
  </ul>
</blockquote>

<h1 id="풀이">풀이</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">priorities</span><span class="p">,</span> <span class="n">location</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="n">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)):</span>
        <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">location</span> <span class="k">in</span> <span class="ss">array:
        </span><span class="n">paper</span> <span class="o">=</span> <span class="n">priorities</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">idx_paper</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">isMax</span> <span class="o">=</span>  <span class="no">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">priorities</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">paper</span> <span class="o">&lt;</span> <span class="n">priorities</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">isMax</span> <span class="o">=</span> <span class="no">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ss">isMax:
            </span><span class="n">priorities</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">paper</span><span class="p">)</span>
            <span class="n">array</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">idx_paper</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">answer</span> <span class="o">-</span> <span class="n">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span></code></pre></figure>

<p>해당 문제는 큐를 이용하여 해결하였습니다. <br />
저의 해결 방법은 순서를 나타내는 변수를 더 생성했습니다. (다른분들 풀이 보니깐.. 저건 비효율적인것같네요.ㅠㅠ)<br />
while문을 통해 배열에 찾고자하는 location이 없다면 while문을 빠져나오는 조건입니다. <br />
while문안에서는 맨앞에 요소를 pop(0)을 통해 꺼내고 남은 priorities 배열요소와 우선순위를 비교해서 큰 우선순위가 있으면 뒤로 append하고 없으면 pop(0) 연산만 하는 코드입니다.</p>

<p>다른분들에 코드를 보면 저의 부족함이 많이 느껴지네요.. ㅠㅠ</p>

<p>지금까지 <strong>프린터 프로그래머스 스택/큐 [파이썬]</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>[프로그래머스 LEVEL2] 탑 프로그래머스 스택/큐 [파이썬]</title>
	  <link>//Algorithm-Top</link>
	  <author></author>
	  <pubDate>2018-10-18T21:00:00+09:00</pubDate>
	  <guid>//Algorithm-Top</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong>입니다. ㅎㅎ</p>

<p>이번에 포스팅할 내용은 스택/큐에 해당되는 <strong>프로그래머스 문제 LEVEL2에 해당되는 탑 알고리즘 문제</strong>를 풀어보도록 하겠습니다.
오랜만에 알고리즘 문제를 풀어보겠습니다!</p>

<p>해당 문제는 <a href="https://programmers.co.kr/learn/courses/30/lessons/42588">프로그래머스 웹페이지</a>에서 만나보실 수 있습니다.</p>

<h1 id="문제">문제</h1>
<p>수평 직선에 높이가 서로 다른 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.</p>

<p>높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다.</p>

<p><strong>제한 사항</strong></p>
<ul>
  <li>heights는 길이 2 이상 100 이하인 정수 배열입니다.</li>
  <li>모든 탑의 높이는 1 이상 100 이하입니다.</li>
  <li>신호를 수신하는 탑이 없으면 0으로 표시합니다.</li>
</ul>

<h1 id="풀이">풀이</h1>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">heights</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span>
    <span class="k">while</span> <span class="ss">heights:
        </span><span class="n">right</span> <span class="o">=</span> <span class="n">heights</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">heights</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="ss">right:
                </span><span class="n">answer</span><span class="p">[</span><span class="n">len</span><span class="p">(</span><span class="n">heights</span><span class="p">)]</span> <span class="o">=</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">break</span>
    <span class="k">return</span> <span class="n">answer</span></code></pre></figure>

<p>풀이 방법은 heights 배열에 오른쪽 부터 pop()을 한 후 pop()한 value와 남은 height의 원소들은 거꾸로 비교하여 큰 수가 나오면 해당 인덱스를 저장하는 방식입니다.<br />
마지막 원소를 pop()한다는 것에서 스택과 연관되어 풀수 있었네요 ㅎㅎ</p>

<p>지금까지 <strong>탑 프로그래머스 스택/큐 [파이썬]</strong>이라는 주제로 포스팅하였습니다!  <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>


	  ]]></description>
	</item>

	<item>
	  <title>이중우선순위큐 알고리즘 [Python] </title>
	  <link>//Algorithm-Heapq-Python</link>
	  <author></author>
	  <pubDate>2018-10-08T05:30:00+09:00</pubDate>
	  <guid>//Algorithm-Heapq-Python</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 네번째 게시물입니다. ㅎㅎ<br />
이번에는 프로그래머스의 알고리즘 문제 중 LEVEL 3 이중우선순위큐 문제를 <strong>heapq 라이브러리</strong>를 이용하여 해결해보겠습니다.</p>

<p><strong>heapq</strong>는 
완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조입니다.<br />
여러 개의 값들 중에서 최댓값이나 최솟값을 일반적인 queue보다 빠르게 찾아내도록 만들어진 자료구조입니다.</p>

<p><strong>heapq라이브러리</strong> 사용방법에 대해서도 후에 포스팅 하겠습니다.</p>

<p>이 문제 또한 프로그래머스 문제인데요. 이것 또한 푼 사람이 아직 별로 없네요~~<br />
문제 자체는 어렵지 않은것 같아요~ 얼마나 효율적이게 해결하냐는 문제같은데 저도 좀 더 봐야겠어요~</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
    <span class="n">import</span> <span class="n">heapq</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">priority_queue</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">operation</span> <span class="k">in</span> <span class="ss">operations:
        </span><span class="n">op</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">operation</span><span class="p">.</span><span class="nf">split</span><span class="p">()</span>
        <span class="c1">#insert</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"I"</span><span class="p">:</span>
            <span class="n">heapq</span><span class="p">.</span><span class="nf">heappush</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">,</span> <span class="n">int</span><span class="p">(</span><span class="n">num</span><span class="p">))</span>
        <span class="c1">#delete </span>
        <span class="n">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">"D"</span> <span class="n">and</span> <span class="ss">priority_queue:
            </span><span class="c1">#max data delete</span>
            <span class="k">if</span> <span class="n">num</span> <span class="o">==</span> <span class="s2">"1"</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">)</span>
                <span class="n">priority_queue</span><span class="p">.</span><span class="nf">pop</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">.</span><span class="nf">index</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
            <span class="c1">#min data delete</span>
            <span class="n">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="s2">"-1"</span><span class="p">:</span>
                <span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">)</span>
    <span class="k">if</span> <span class="ss">priority_queue:
        </span><span class="c1">#max</span>
        <span class="n">answer</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">))</span>
        <span class="c1">#min</span>
        <span class="n">answer</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">heapq</span><span class="p">.</span><span class="nf">heappop</span><span class="p">(</span><span class="n">priority_queue</span><span class="p">))</span>
    <span class="ss">else:
        </span><span class="n">answer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">answer</span></code></pre></figure>

<p>저는 이렇게 풀었는데요… 시간초과 걸릴것같아서 heaq를 사용했는데 
다른 분들이 적은 답을보니 heapq사용하지 않고 배열에 넣고 min max 값을 찾아도 시간초과가 
나지 않는 것같습니다.<br />
여러가지 방법으로 풀어보세요~</p>

<p>지금까지 파이썬의 heapq 라이브러리를 이용한 프로그래머스 LEVEL 3문제인 <strong>이중우선순위큐  풀이</strong>였습니다. <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>

	<item>
	  <title>네트워크 알고리즘 [Python] </title>
	  <link>//Algorithm-DFS-python</link>
	  <author></author>
	  <pubDate>2018-10-08T05:00:00+09:00</pubDate>
	  <guid>//Algorithm-DFS-python</guid>
	  <description><![CDATA[
	     <p>안녕하세요! <strong>Do My Best 블로그</strong> 세번째 게시물입니다. ㅎㅎ<br />
이번에는 프로그래머스의 알고리즘 문제 중 LEVEL 3 네트워크 문제를 DFS알고리즘으로 해결해보겠습니다.</p>

<p><strong>DFS는 Depth First Search</strong>로 깊이 우선 탐색입니다.</p>

<p>DFS알고리즘은 검색을 통해 자세히 나와있으니 참고 하시면 되겠습니다!<br />
여기서는 간단하게 DFS알고리즘에대해서 설명하고 넘어가겠습니다. <br />
DFS알고리즘은 자식의 자식 끝까지 먼저 탐색합니다.! 너무 간단한가요??</p>

<p>먼저 프로그래머스의 네트워크 문제는 올라온지 얼마 안되서 그런지 문제 푼 분들이 많이 없네요?<br />
무려!! <strong>29명!</strong></p>

<p><img src="/assets/images/2018-10-07-Algorithm-DFS-Python/programmers_network.png" /></p>

<p>참고하면서 문제를 한번 풀어보겠습니다.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">solution</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">computers</span><span class="p">):</span>
    <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">computers</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">while</span> <span class="ss">stack:
            </span><span class="n">j</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="n">len</span><span class="p">(</span><span class="n">computers</span><span class="p">)):</span>
                <span class="c1">#pop한 정점과 연결되어있고 방문하지 않은곳 stack에 저장</span>
                <span class="k">if</span> <span class="n">computers</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span><span class="mi">1</span> <span class="n">and</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1">#stack에 저장하고나면 해당정점과 다시 pop하면서 정점과 연결된 곳을 모두 방문함</span>
                    <span class="n">stack</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">while</span> <span class="mi">0</span> <span class="k">in</span> <span class="ss">visited:
        </span><span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">computers</span><span class="p">,</span> <span class="n">visited</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">answer</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">answer</span></code></pre></figure>

<p>지금까지 DFS 알고리즘을 이용한 프로그래머스 LEVEL 3문제인 <strong>네트워크 풀이</strong>였습니다. <br />
해당 게시물에 문제가 있다면 댓글을 통해 피드백해주시면 감사하겠습니다~ 같이 공부해요~^^</p>

<p><code class="highlighter-rouge">방문해주신분들 댓글 한개씩 달아주시면 감사하겠습니다~~^^</code></p>

	  ]]></description>
	</item>


</channel>
</rss>
